-- Setup r13
Reset $r0 0
SetAccum 14
Get/Set $r2 1
SetAccum 31
Add $r0 1	-- 31 + 31 + 1 = 63
Get/Set $r1 1
Add $r0 1	-- 63 + 63 + 1 = 127
Add $r1 1	-- 127 + 63 + 1 = 191
Add $r2 0 -- 191 + 14 + 0
Get/Set $r13 1
SetAccum 0
Get/Set $r1 1
Get/Set $r2 1
-- Start Loop, Load in LSW and MSW based on i
Get/Set $r1 0
Add $r0 0           -- Multiply i by 2 (since we iterate by 1)
Load/Store $r2 0		-- $r2 = mem[$r1]
Load/Store $r11 0		-- $r11 = mem[$r1]
Add $r15 1			-- 0 + 0 + 1
Load/Store $r3 0		-- $r3 = mem[$r1 + 1]
Load/Store $r5 0		-- $r5 = mem[$r1 + 1]
SetAccum 0
Get/Set $r14 1
-- Calculate outMSW
Get/Set $r5 0	
L/RShift $r0 0
MSBtoLSB/MSB $r11 0
L/RShift $r11 0
Get/Set $r5 1
Get/Set $r14 0
Add $r15 1			-- Increment loop counter
Get/Set $r14 1
Equals/NotImm 4 1	-- Set LSB of $r5 to MSB of $r2 4 times
Branch -9			-- Loop back to "Calculate outMSW" 4 times
-- Calculate p8
L/RShift $r5 0
Get/Set $r5 0			-- b11 b10 b9 b8 b7 b6 b5 0
Get/Set $r11 1
SetAccum 0				-- 0 0 0 0 0 0 0 0
MSBtoLSB/MSB $r11 0	-- 0 0 0 0 0 0 0 b11
Get/Set $r6 1
SetAccum 0
Get/Set $r14 1
-- Loop p8 calculation
L/RShift $r11 0		
MSBtoLSB/MSB $r11 0
XOR $r6 0
Get/Set $r6 1			
Get/Set $r14 0	
Add $r15 1
Get/Set $r14 1
Equals/NotImm 3 0
Branch 4			-- Branch on loop 3, save $r6, go to "Helper branch for p4"
Get/Set $r14 0
Equals/NotImm 6 1
Branch -11			-- Loop back to "Loop p8 calculation" 6 times
-- Helper branch for p4, which needs ^(b11:b8)
Get/Set $r14 0
Equals/NotImm 3 1	-- Skip if not on 3rd loop
Branch +7			-- If we’re not in loop 3 of Loop p8 calculation, skip this
Get/Set $r6 0
Get/Set $r7 1
SetAccum 20
Get/Set $r12 1
SetAccum 0
BranchReg $r12 1			-- Loop back to "Loop p8 calculation"
-- p8 is now in $r6 LSB. Calculate p4, which already has ^(b11:b8) done
Get/Set $r2 0
Get/Set $r11 1
L/RShift $r11 1
SetAccum 0
Get/Set $r14 1
-- Loop p4 calculate
LSBtoLSB/MSB $r11 0
L/RShift $r11 1
XOR $r7 0
Get/Set $r7 1
Get/Set $r14 0
Add $r15 1
Get/Set $r14 1
Equals/NotImm 3 1
Branch -8				-- Branch back to "Loop p4 calculate"
-- Calculate p2
Get/Set $r5 0
Get/Set $r11 1
MSBtoLSB/MSB $r11 0	-- b11
Get/Set $r8 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b10
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b7
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b6
XOR $r8 0
Get/Set $r8 1
Get/Set $r2 0
Get/Set $r11 1
L/RShift $r11 0
L/RShift $r11 0
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b4
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b2
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b1
XOR $r8 0
Get/Set $r8 1
-- Calculate p1
Get/Set $r5 0
Get/Set $r11 1
MSBtoLSB/MSB $r11 0	-- b11
Get/Set $r9 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b9
XOR $r9 0
Get/Set $r9 1
Get/Set $r2 0
Get/Set $r11 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b7
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b5
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b4
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b2
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b1
XOR $r9 0
Get/Set $r9 1
-- Calculate p16
Get/Set $r5 0
Get/Set $r11 1
SetAccum 0
MSBtoLSB/MSB $r11 0
Get/Set $r10 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0
XOR $r10 0
Get/Set $r10 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0
XOR $r10 0
Get/Set $r10 1
Get/Set $r2 0
Get/Set $r11 1
SetAccum 0
Get/Set $r14 1
-- Loop p16 (b8:b1)
MSBtoLSB/MSB $r11 0
L/RShift $r11 0
XOR $r10 0
Get/Set $r10 1
Get/Set $r14 0
Add $r15 1
Get/Set $r14 1
Equals/NotImm 8 1
Branch -8				-- Branch back to "Loop p16"
-- Xor with p8, p4, p2, p1, p16
Get/Set $r10 0
XOR $r6 0
XOR $r7 0
XOR $r8 0
XOR $r9 0
Get/Set $r10 1
-- Put together outLSW
Get/Set $r2 0
L/RShift $r0 0
L/RShift $r0 0
L/RShift $r0 0
L/RShift $r0 0
Get/Set $r11 1
SetAccum 0
MSBtoLSB/MSB $r11 0	-- b4
L/RShift $r0 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- b3
L/RShift $r0 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- b2
L/RShift $r0 0
LSBtoLSB/MSB $r7 0		-- p4
L/RShift $r0 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- b1
L/RShift $r0 0
LSBtoLSB/MSB $r8 0		-- p2
L/RShift $r0 0
LSBtoLSB/MSB $r9 0		-- p1
L/RShift $r0 0
LSBtoLSB/MSB $r10 0	-- p16
Get/Set $r4 1
-- Finish outMSW
Get/Set $r5 0
LSBtoLSB/MSB $r6 0		-- p8
Get/Set $r5 1
-- Put items into mem
SetAccum 30
Get/Set $r12 1
Get/Set $r1 0
Add $r0 0           -- Multiply i by 2 (since we iterate by 1)
Add $r12 0		-- i + 30 (for output mem)
Load/Store $r4 1	-- mem[i + 30] = r4
Add $r15 1
Load/Store $r5 1	-- mem[i + 31] = r5
Get/Set $r1 0
Add $r15 1		-- Add 1 to i
Get/Set $r1 1
Equals/NotImm 15 1	-- Check if loop is over
BranchReg $r13 1   -- Branch back to start loop
Reset $r0 1			-- End program
-- Set up program 2
SetAccum 31
Add $r0 1 		-- 31 + 31 + 1 = 63
Add $r15 1		-- 63 + 0 + 1 = 64
Get/Set $r1 1
-- Start of loop
Get/Set $r1 0
Load/Store $r12 0
Load/Store $r2 0  -- LSW
Add $r15 1
Load/Store $r13 0
Load/Store $r3 0  -- MSW
SetAccum 0
Get/Set $r14 1
-- Loop for returning MSW to normal input for program 1
Get/Set $r2 0
L/RShift $r3 1
LSBtoLSB/MSB $r3 1		-- Take LSB of MSW, put in MSB of LSW
L/RShift $r0 1
Get/Set $r2 1
Get/Set $r14 0
Add $r15 1
Get/Set $r14 1
Equals/NotImm 4 1		-- If != 4, loop back
Branch -9
-- Finish returning MSW to normal
L/RShift $r3 1
-- Finish returning LSW to normal (currently 0 b8 b7 b6 b5 0 0 0)
L/RShift $r2 1
L/RShift $r2 1    -- Now 0 0 0 b8 b7 b6 b5 0
Get/Set $r12 0
Get/Set $r6 1
Get/Set $r2 0
MSBtoLSB/MSB $r6 0
L/RShift $r0 0
L/RShift $r6 0
MSBtoLSB/MSB $r6 0
L/RShift $r0 0
L/RShift $r6 0
MSBtoLSB/MSB $r6 0
L/RShift $r0 0    -- Now b8 b7 b6 b5 b4 b3 b2 0
L/RShift $r6 0
L/RShift $r6 0
MSBtoLSB/MSB $r6 0
Get/Set $r2 1
-- Cleanse registers for program 1
SetAccum 0
Get/Set $r12 1
Get/Set $r13 1
Get/Set $r5 1
Get/Set $r6 1
-- Program 1
-- Perform program 1 here, but it’s not exactly a copy paste. Load LSW and MSW replaced.
-- Loop removed.
Get/Set $r2 0
Get/Set $r11 1
Get/Set $r3 0		-- $r3 = mem[$r1 + 1]
Get/Set $r5 1		-- $r5 = mem[$r1 + 1]
SetAccum 0
Get/Set $r14 1
-- Calculate outMSW
Get/Set $r5 0	
L/RShift $r0 0
MSBtoLSB/MSB $r11 0
L/RShift $r11 0
Get/Set $r5 1
Get/Set $r14 0
Add $r15 1			-- Increment loop counter
Get/Set $r14 1
Equals/NotImm 4 1	-- Set LSB of $r5 to MSB of $r2 4 times
Branch -9			-- Loop back to "Calculate outMSW" 4 times
-- Calculate p8
L/RShift $r5 0
Get/Set $r5 0			-- b11 b10 b9 b8 b7 b6 b5 0
Get/Set $r11 1
SetAccum 0				-- 0 0 0 0 0 0 0 0
MSBtoLSB/MSB $r11 0	-- 0 0 0 0 0 0 0 b11
Get/Set $r6 1
SetAccum 0
Get/Set $r14 1
-- Loop p8 calculation
L/RShift $r11 0		
MSBtoLSB/MSB $r11 0
XOR $r6 0
Get/Set $r6 1			
Get/Set $r14 0	
Add $r15 1
Get/Set $r14 1
Equals/NotImm 3 0
Branch 4			-- Branch on loop 3, save $r6, go to "Helper branch for p4"
Get/Set $r14 0
Equals/NotImm 6 1
Branch -11			-- Loop back to "Loop p8 calculation" 6 times
-- Helper branch for p4, which needs ^(b11:b8)
Get/Set $r14 0
Equals/NotImm 3 1	-- Skip if not on 3rd loop
Branch +7			-- If we’re not in loop 3 of Loop p8 calculation, skip this
Get/Set $r6 0
Get/Set $r7 1
SetAccum 20
Get/Set $r12 1
SetAccum 0
BranchReg $r12 1			-- Loop back to "Loop p8 calculation"
-- p8 is now in $r6 LSB. Calculate p4, which already has ^(b11:b8) done
Get/Set $r2 0
Get/Set $r11 1
L/RShift $r11 1
SetAccum 0
Get/Set $r14 1
-- Loop p4 calculate
LSBtoLSB/MSB $r11 0
L/RShift $r11 1
XOR $r7 0
Get/Set $r7 1
Get/Set $r14 0
Add $r15 1
Get/Set $r14 1
Equals/NotImm 3 1
Branch -8				-- Branch back to "Loop p4 calculate"
-- Calculate p2
Get/Set $r5 0
Get/Set $r11 1
MSBtoLSB/MSB $r11 0	-- b11
Get/Set $r8 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b10
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b7
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b6
XOR $r8 0
Get/Set $r8 1
Get/Set $r2 0
Get/Set $r11 1
L/RShift $r11 0
L/RShift $r11 0
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b4
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b2
XOR $r8 0
Get/Set $r8 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b1
XOR $r8 0
Get/Set $r8 1
-- Calculate p1
Get/Set $r5 0
Get/Set $r11 1
MSBtoLSB/MSB $r11 0	-- b11
Get/Set $r9 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b9
XOR $r9 0
Get/Set $r9 1
Get/Set $r2 0
Get/Set $r11 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b7
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b5
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b4
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b2
XOR $r9 0
Get/Set $r9 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- xor b1
XOR $r9 0
Get/Set $r9 1
-- Calculate p16
Get/Set $r5 0
Get/Set $r11 1
SetAccum 0
MSBtoLSB/MSB $r11 0
Get/Set $r10 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0
XOR $r10 0
Get/Set $r10 1
L/RShift $r11 0
MSBtoLSB/MSB $r11 0
XOR $r10 0
Get/Set $r10 1
Get/Set $r2 0
Get/Set $r11 1
SetAccum 0
Get/Set $r14 1
-- Loop p16 (b8:b1)
MSBtoLSB/MSB $r11 0
L/RShift $r11 0
XOR $r10 0
Get/Set $r10 1
Get/Set $r14 0
Add $r15 1
Get/Set $r14 1
Equals/NotImm 8 1
Branch -8				-- Branch back to "Loop p16"
-- Xor with p8, p4, p2, p1, p16
Get/Set $r10 0
XOR $r6 0
XOR $r7 0
XOR $r8 0
XOR $r9 0
Get/Set $r10 1
-- Put together outLSW
Get/Set $r2 0
L/RShift $r0 0
L/RShift $r0 0
L/RShift $r0 0
L/RShift $r0 0
Get/Set $r11 1
SetAccum 0
MSBtoLSB/MSB $r11 0	-- b4
L/RShift $r0 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- b3
L/RShift $r0 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- b2
L/RShift $r0 0
LSBtoLSB/MSB $r7 0		-- p4
L/RShift $r0 0
L/RShift $r11 0
MSBtoLSB/MSB $r11 0	-- b1
L/RShift $r0 0
LSBtoLSB/MSB $r8 0		-- p2
L/RShift $r0 0
LSBtoLSB/MSB $r9 0		-- p1
L/RShift $r0 0
LSBtoLSB/MSB $r10 0	-- p16
Get/Set $r4 1
-- Finish outMSW
Get/Set $r5 0
LSBtoLSB/MSB $r6 0		-- p8
Get/Set $r5 1
-- r2 = LSW, r3 = MSW, r4 = outLSW, r5 = outMSW, r6 = np8, r7 = np4, r8 = np2, r9 = np1
-- r10 = np16, r11 = op16, r12 = old LSW, r13 = old MSW, r14 = etc branch, r15 = zero
-- End program 1
-- Load in old LSW and MSW
Get/Set $r1 0
Load/Store $r12 0
Load/Store $r14 0
Add $r15 1
Load/Store $r13 0
-- Extract np bits
SetAccum 0
LSBtoLSB/MSB $r5 0  -- p8
Get/Set $r6 1
SetAccum 0
LSBtoLSB/MSB $r4 0  -- p16
L/RShift $r4 1
Get/Set $r10 1
SetAccum 0
LSBtoLSB/MSB $r4 0  -- p1
L/RShift $r4 1
Get/Set $r9 1
SetAccum 0
LSBtoLSB/MSB $r4 0  -- p2
L/RShift $r4 1
L/RShift $r4 1
Get/Set $r8 1
SetAccum 0
LSBtoLSB/MSB $r4 0  -- p4
Get/Set $r7 1
-- r2 = op8, r3 = op4, r4 = op2, r5 = op1, r6 = np8, r7 = np4, r8 = np2, r9 = np1
-- r10 = np16, r11 = op16, r12 = old LSW, r13 = old MSW, r14 = etc branch, r15 = zero
-- Get new p16 by first un-xoring r6-r9
SetAccum 0
Get/Set $r10 0
XOR $r6 0
XOR $r7 0
XOR $r8 0
XOR $r9 0
Get/Set $r10 1
-- xor op bits into np16, also get op16
SetAccum 0
LSBtoLSB/MSB $r13 0
Get/Set $r2 1
XOR $r10 0			-- xor op8
Get/Set $r10 1
LSBtoLSB/MSB $r14 0
Get/Set $r11 1  -- get op16 (but don't xor)
L/RShift $r14 1
LSBtoLSB/MSB $r14 0
Get/Set $r5 1
XOR $r10 0			-- xor op1
Get/Set $r10 1
L/RShift $r14 1
LSBtoLSB/MSB $r14 0
Get/Set $r4 1
XOR $r10 0			-- xor op2
Get/Set $r10 1
L/RShift $r14 1
L/RShift $r14 1
LSBtoLSB/MSB $r14 0
Get/Set $r3 1
XOR $r10 0			-- xor op4
Get/Set $r10 1
-- Check equality of p16
Get/Set $r10 0
XOR $r11 0
Get/Set $r10 1
-- Check equality of p8
Get/Set $r6 0
XOR $r2 0
Get/Set $r6 1
-- Check equality of p4
Get/Set $r7 0
XOR $r3 0
Get/Set $r7 1
-- Check equality of p2
Get/Set $r8 0
XOR $r4 0
Get/Set $r8 1
-- Check equality of p1
Get/Set $r9 0
XOR $r5 0
Get/Set $r9 1
r2 = p8+p4+p2+p1+p16, r3 = outLSW, r4 = outMSW, r5 = temp, r6 = p8, r7 = p4, r8 = p2, r9 = p1
r10 = p16, r11 = temp 2, r12 = old LSW, r13 = old MSW, r14 = etc branch, r15 = zero
-- Setup outLSW and outMSW
Get/Set $r13 0
Get/Set $r5 1
-- OutMSW
SetAccum 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r5 0
Get/Set $r4 1
-- OutLSW
SetAccum 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
Get/Set $r11 1
Get/Set $r12 0
Get/Set $r5 1
Get/Set $r11 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
L/RShift $r0 0
L/RShift $r5 0
L/RShift $r5 0
MSBtoLSB/MSB $r5 0
Get/Set $r3 1
-- Check for perfect equality first
-- Add branchReg past all of this
SetAccum 7
Get/Set $r14 1
SetAccum 0
Add $r6 0
Add $r7 0
Add $r8 0
Add $r9 0
Add $r10 0
Get/Set $r2 1
Equals/NotImm 0 0	-- If 0, everything is equal
BranchReg $r14 0		-- Branch past this if equal to 0
-- Check if 2 bit error
Get/Set $r10 0
Equals/NotImm 0 1	-- If equal, 2 bit error
Branch 4		-- Branch past this if equal to 0
Get/Set $r4 0
FlipBit 7
Get/Set $r4 1
-- Check for all unequal parity bits (bit 11)
Get/Set $r2 0		-- If this is 5, it’s bit 11
Equals/NotImm 5 1	-- If equal, flip bit 11
Branch 4		-- Else, branch past
Get/Set $r4 0
FlipBit 2
Get/Set $r4 1
-- Check for 4 unequal parity bits (bit 10, 9, 7, 4)
SetAccum 25
Get/Set $r14 1
Get/Set $r2 0		-- If this is 4, it’s bit 10, 9, 7, or 4
Equals/NotImm 4 1	-- If equal, keep going, else skip
BranchReg $r14 0
Get/Set $r6 0
Equals/NotImm 0 1	-- If equal, flip bit 4
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 3
Get/Set $r3 1
Get/Set $r7 0
Equals/NotImm 0 1	-- If equal, flip bit 7
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 6
Get/Set $r3 1
Get/Set $r8 0
Equals/NotImm 0 1	-- If equal, flip bit 9
Branch 4		-- Else, branch past
Get/Set $r4 0
FlipBit 0
Get/Set $r4 1
Get/Set $r9 0
Equals/NotImm 0 1	-- If equal, flip bit 10
Branch 4		-- Else, branch past
Get/Set $r4 0
FlipBit 1
Get/Set $r4 1
-- Check for 3 unequal parity bits, with one of them being p8 (bits 8 6 5)
SetAccum 23
Add $r0 1		-- 47
Get/Set $r14 1
Get/Set $r2 0		-- If this is 3, it’s bits 8, 6, 5, 3, 2, or 1
Equals/NotImm 3 1	-- If equal, keep going, else skip to store
BranchReg $r14 0
SetAccum 19
Get/Set $r14 1
Get/Set $r6 0
Equals/NotImm 1 1	-- If equal, keep going (bits 8 6 5), else skip to bits 3 2 1
BranchReg $r14 0
Get/Set $r7 0
Equals/NotImm 1 1	-- If equal, flip bit 8
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 7
Get/Set $r3 1
Get/Set $r8 0
Equals/NotImm 1 1	-- If equal, flip bit 6
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 5
Get/Set $r3 1
Get/Set $r9 0
Equals/NotImm 1 1	-- If equal, flip bit 5
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 4
Get/Set $r3 1
-- Check for remaining bits (bits 3 2 1)
SetAccum 19
Get/Set $r14 1
Get/Set $r6 0
Equals/NotImm 0 1	-- If equal, keep going (bits 3 2 1), else skip
BranchReg $r14 0
Get/Set $r7 0
Equals/NotImm 0 1	-- If equal, flip bit 1
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 0
Get/Set $r3 1
Get/Set $r8 0
Equals/NotImm 0 1	-- If equal, flip bit 2
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 1
Get/Set $r3 1
Get/Set $r9 0
Equals/NotImm 0 1	-- If equal, flip bit 3
Branch 4		-- Else, branch past
Get/Set $r3 0
FlipBit 2
Get/Set $r3 1
-- Store result
SetAccum 30
Add $r1 0
Load/Store $r3 1
Add $r15 1
Load/Store $r4 1
Get/Set $r1 0
Add $r15 1
Add $r15 1
Get/Set $r1 1
-- Set branch
SetAccum 25
Add $r0 1 51
Add $r0 1 103
Add $r0 0 206
Get/Set $r14 1
-- Check if loop ends
SetAccum 23
Add $r0 1	-- 47
Add $r0 0	-- 94
Equals/Not $r1 1	-- If i = 94, exit loop
BranchRegOff $r14 1	-- Go back to loop start
Reset $r0 1
-- Start program 3
-- R1 = i, r2 = j, r3 = etc branch, r4 = pattern, r5 = currentByte, r6 = nextByte, r7 = count (194), r8 = xored, r9 = countPerByte (193),
-- r10 = byteCounted, r11 = countWithinByte, r12 = 3 (for countWithinByte), r13 = 159 (end of for loop), r14 = etc loop counter
-- r15 = 0
— Start by initializing $r1(i) to hold 128
SetAccum 31 — 31
Get/Set $r2 1 — Set $r2 to 31 for use later
Add $r0 1 — 31 + 31 + 1 = 63
Add $r0 1 -- 63 + 63 + 1 = 127
Add $r15 1 —127 + 0 + 1 = 128
Get/Set $r1 1
Load/Store $r5 0
Add $r15 1 — 128 + 0 + 1 = 129 (nextbyte)
Load/Store $r6 0
SetAccum 31
Add $r0 1		— 31 + 31 + 1 = 63
Add $r0 1		— 63 + 63 + 1 = 127
Add $r2 1		— 127 + 31 + 1 = 159
Get/Set $r13 1
SetAccum 4
Get/Set $r12 1
Get/Set $r1 0
— Initialize $r4(pattern)
Add $r2 1 — 128 + 31 + 1 = 160
Load/Store $r4 0
L/RShift $r4 0
L/RShift $r4 0
L/RShift $r4 0
SetAccum 0
Get/Set $r2 1
— Loop A
Get/Set $r5 0
XOR $r4 0		-- Check for pattern match
L/RShift $r0 1
L/RShift $r0 1
L/RShift $r0 1
Get/Set $r8 1
SetAccum 18
Get/Set $r3 1		-- Set branch
SetAccum 0
Equals/Not $r8 1 — If r8 = 0, the pattern matches, else we move on
BranchReg $r3 0   — Skip to "Check if program ends"
-- Adding to the counts
Get/Set $r7 0
Add $r15 1 — If we reach here, add 1 to count
Get/Set $r7 1
-- If j is 0 to 3, increment countWithinByte
Get/Set $r2 0
LTE $r12 1
Branch 12 -- Skip to end of for loop A
Get/Set $r11 0
Add $r15 1		-- Add to countWithinByte
Get/Set $r11 1
SetAccum 0
Equals/Not $r10 1   — If  r10 = 0, we haven’t counted this byte, countPerByte+1, else skip
Branch 6    — Skip program check end
Get/Set $r9 0
Add $r15 1		-- Add to countPerByte
Get/Set $r9 1
SetAccum 1
Get/Set $r10 1		-- Set byteCounted
— Check if program ends here
SetAccum 3
Equals/Not $r2 1	-- Check if j = 3 (last offset before ending)
Branch 7		-- If not, skip to end of for loop A
SetAccum 17
Add $r0 0
Get/Set $r3 1		-- Set branch
Get/Set $r13 0		-- Sets r0 to 159
Equals/Not $r1 0	— Check if we’ve finished our outer for loop
BranchReg $r3 0		— If we have, branch to the end
— End of for loop A, offset byte by j and check again, unless j = 8!
Get/Set $r2 0
Add $r15 1	— Increment j by 1
Get/Set $r2 1
SetAccum 8
Equals/Not $r2 0
Branch 11		— If we reach j = 8, branch to Loop C
— Take another bit from nextByte and put into currentByte
L/RShift $r5 0
Get/Set $r5 0
MSBtoLSB/MSB $r6 0 — Set MSB of next byte to LSB of current byte
Get/Set $r5 1
L/RShift $r6 0
SetAccum 26
Add $r0 0
Get/Set $r3 1
SetAccum 0
BranchReg $r3 1		— Branch back to "Loop A"
— Loop C
Get/Set $r1 0			
Add $r15 1			-- Iterate i
Get/Set $r1 1
SetAccum 0
Get/Set $r10 1			-- Reset byteCounted
Get/Set $r2 1			-- Reset j
Get/Set $r1 0
Load/Store $r5 0	— Load new current byte
Add $r15 1
Load/Store $r6 0	— Load new next byte
Add $r15 1
SetAccum 17
Add $r0 0
Add $r0 1
Get/Set $r3 1
SetAccum 0
BranchReg $r3 1	— Branch back to Begin Loop A
— End
SetAccum 24
Add $r0 0		— 24 + 24 = 48
Add $r0 0		— 48 + 48 =  96
Add $r0 0		— 96 + 96 = 192
Load/Store $r11 1	— Store count within byte
Add $r15 1
Load/Store $r9 1	-- Store count per byte
Add $r15 1
Load/Store $r7 1	-- Store count
Reset $r0 1
